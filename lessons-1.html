<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Unreal</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/fonts/font-awesome.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Aclonica">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Allerta">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
    <link rel="stylesheet" href="assets/css/-Team-Rotating-Cards-BS4-.css">
    <link rel="stylesheet" href="assets/css/Navigation-Clean.css">
    <link rel="stylesheet" href="assets/css/News-Cards.css">
    <link rel="stylesheet" href="assets/css/Responsive-Youtube-Embed.css">
    <link rel="stylesheet" href="assets/css/styles.css">
</head>

<body>
    <div>
        <nav class="navbar navbar-light navbar-expand-md navigation-clean" style="background-color: rgb(255,255,255);">
            <div class="container"><a class="navbar-brand" href="index.html" style="color: rgba(0,0,0,0.9);font-family: Roboto, sans-serif;"><img src="assets/img/unreal-engine-icon-27.jpg.png" style="width: 76px;">Уроки Unreal Engine</a><button class="navbar-toggler" data-toggle="collapse" data-target="#navcol-1"><span class="sr-only">Toggle navigation</span><span class="navbar-toggler-icon"></span></button>
                <div
                class="collapse navbar-collapse" id="navcol-1">
                <ul class="nav navbar-nav ml-auto">
                    <li class="nav-item" role="presentation"><a class="nav-link" href="index.html">Главная</a></li>

                    <li class="nav-item dropdown"><a class="nav-link" href="lessons.html">Уроки</a>



                  <li class="nav-item" role="presentation"><a class="nav-link" href="about.html">О разработке</a></li>
              </ul>
          </div>
      </div>
  </nav>
</div>
<div class="container">
    <section class="py-5">
        <h1 class="text-center text-uppercase">ОСНОВЫ&nbsp;ООП</h1>
        <h2 class="text-center text-uppercase text-secondary mb-5"></h2>
        <div class="row">
            <div class="col">
                <p class="shirt">Все основанные на объектах языки (C#, Java, С++, Smalltalk, Visual Basic и т.п.) должны отвечать трем основным принципам объектно-ориентированного программирования (ООП), которые перечислены ниже:</p>
                <p class="shirt"><strong><em>Инкапсуляция</em></strong>&nbsp;— это механизм программирования, объединяющий вместе код и данные, которыми он манипулирует, исключая как вмешательство извне, так и неправильное использование данных. В объектно-ориентированном
                    языке данные и код могут быть объединены в совершенно автономный черный ящик. Внутри такого ящика находятся все необходимые данные и код. Когда код и данные связываются вместе подобным образом, создается объект. Иными словами,&nbsp;<strong>объект</strong>&nbsp;—
                    это элемент, поддерживающий инкапсуляцию.Т.е. инкапсуляция представляет собой способности языка скрывать излишние детали реализации от пользователя объекта. Например, предположим, что используется класс по имени&nbsp;<em>DatabaseReader</em>,
                    который имеет два главных метода: Open() и Close().Фиктивный класс DatabaseReader инкапсулирует внутренние детали нахождения, загрузки, манипуляций и закрытия файла данных. Программистам нравится инкапсуляция, поскольку этот принцип
                    ООП&nbsp;<em>упрощает кодирование</em>. Нет необходимости беспокоиться о многочисленных строках кода, которые работают "за кулисами", чтобы реализовать функционирование класса DatabaseReader. Все, что потребуется — это создать
                    экземпляр и отправлять ему соответствующие сообщения (например, "открыть файл по имени AutoLot.mdf, расположенный на диске С:").С идеей инкапсуляции программной логики тесно связана идея защиты данных. В идеале данные состояния
                    объекта должны быть специфицированы с использованием ключевого слова&nbsp;<em>private</em>&nbsp;(или, возможно,&nbsp;<em>protected</em>). Таким образом, внешний мир должен вежливо попросить, если захочет изменить или получить лежащее
                    в основе значение. Это хороший принцип, поскольку общедоступные элементы данных можно легко повредить (даже нечаянно, а не преднамеренно).Основной единицей инкапсуляции в C# является&nbsp;<strong>класс</strong>, который определяет
                    форму объекта. Он описывает данные, а также код, который будет ими оперировать. В C# описание класса служит для построения объектов, которые являются экземплярами класса. Следовательно, класс, по существу, представляет собой ряд
                    схематических описаний способа построения объекта.Код и данные, составляющие вместе класс, называют&nbsp;<em>членами</em>. Данные, определяемые классом, называют&nbsp;<em>полями</em>, или&nbsp;<em>переменными экземпляра</em>. А
                    код, оперирующий данными, содержится в&nbsp;<em>функциях-членах</em>, самым типичным представителем которых является метод. В C# метод служит в качестве аналога подпрограммы. (К числу других функций-членов относятся свойства, события
                и конструкторы.) Таким образом, методы класса содержат код, воздействующий на поля, определяемые этим классом.</p>
                <p class="shirt">Следующий принцип ООП —&nbsp;<strong>наследование</strong>&nbsp;— касается способности языка позволять строить новые определения классов на основе определений существующих классов. По сути, наследование позволяет расширять поведение
                    базового (или родительского) класса, наследуя основную функциональность в производном подклассе (также именуемом дочерним классом).&nbsp;Т.е. наследование представляет собой процесс, в ходе которого один объект приобретает свойства
                    другого объекта. Это очень важный процесс, поскольку он обеспечивает принцип иерархической классификации. Если вдуматься, то большая часть знаний поддается систематизации благодаря иерархической классификации по нисходящей.Если
                    не пользоваться иерархиями, то для каждого объекта пришлось бы явно определять все его свойства. А если воспользоваться наследованием, то достаточно определить лишь те свойства, которые делают объект особенным в его классе. Он
                может также наследовать общие свойства своего родителя. Следовательно, благодаря механизму наследования один объект становится отдельным экземпляром более общего класса.</p>
                <p class="shirt">Последний принцип ООП —&nbsp;<strong>полиморфизм</strong>. Он обозначает способность языка трактовать связанные объекты в сходной манере. В частности, этот принцип ООП позволяет базовому классу определять набор членов (формально называемый&nbsp;<em>полиморфным интерфейсом</em>),
                    которые доступны всем наследникам. Полиморфный интерфейс класса конструируется с использованием любого количества виртуальных или абстрактных членов.По сути,&nbsp;<em>виртуальный член</em>&nbsp;— это член базового класса, определяющий
                    реализацию по умолчанию, которая может быть изменена (или, говоря более формально, переопределена) в производном классе. В отличие от него,&nbsp;<em>абстрактный метод</em>&nbsp;— это член базового класса, который не предусматривает
                    реализации по умолчанию, а предлагает только сигнатуру. Когда класс наследуется от базового класса, определяющего абстрактный метод, этот метод обязательно должен быть переопределен в производном классе. В любом случае, когда производные
                    классы переопределяют члены, определенные в базовом классе, они по существу переопределяют свою реакцию на один и тот же запрос.Рассмотрим для примера&nbsp;стек, т.е. область памяти, функционирующую по принципу "последним пришел
                    — первым обслужен". Допустим, что в программе требуются три разных типа стеков: один — для целых значений, другой — для значений с плавающей точкой, третий — для символьных значений. В данном примере алгоритм, реализующий все эти
                    стеки, остается неизменным, несмотря на то, что в них сохраняются разнотипные данные. В языке, не являющемся объектно-ориентированным, для этой цели пришлось бы создать три разных набора стековых подпрограмм с разными именами.
                    Но благодаря полиморфизму для реализации всех трех типов стеков в C# достаточно создать лишь один общий набор подпрограмм. Зная, как пользоваться одним стеком, вы сумеете воспользоваться и остальными.В более общем смысле понятие
                    полиморфизма нередко выражается следующим образом: "<strong>один интерфейс — множество методов</strong>". Это означает, что для группы взаимосвязанных действий можно разработать общий интерфейс. Полиморфизм помогает упростить программу,
                    позволяя использовать один и тот же интерфейс для описания общего класса действий. Выбрать конкретное действие (т.е. метод) в каждом отдельном случае — это задача компилятора. Программисту не нужно делать это самому. Ему достаточно
                запомнить и правильно использовать общий интерфейс.</p>
            </div>
        </div>
    </section>
</div>
<script src="assets/js/jquery.min.js"></script>
<script src="assets/bootstrap/js/bootstrap.min.js"></script>
</body>

</html>